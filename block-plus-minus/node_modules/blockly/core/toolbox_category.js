/**
 * @license
 * Copyright 2020 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */

/**
 * @fileoverview A toolbox category. Holds the blocks in a category.
 * @author aschmiedt@google.com (Abby Schmiedt)
 */
'use strict';

goog.provide('Blockly.ToolboxCategory');

goog.require('Blockly.Toolbox');


/**
 * Class for a Toolbox Category.
 * @param {string} name The name of the category.
 * @param {Object|string} contents The contents of the category.
 * @constructor
 */
Blockly.ToolboxCategory = function(name, contents) {
  this.name = name;

  /**
   * The contents of the category defined in json.
   * @type {Object}
   */
  this.contents = this.parseContents(contents);
};

/**
 * Parse the contents of the category.
 * @param {Object|string} contents The contents of the category.
 */
Blockly.ToolboxCategory.prototype.parseContents = function(contents) {
  if (typeof contents === 'string') {
    var xml = Blockly.utils.xml.textToDomDocument(contents).childNodes[0];

  } else {
    return contents;
  }
};

Blockly.ToolboxCategory.prototype.syncTrees_ = function(xml) {
  var openNode = null;
  var lastElement = null;
  for (var i = 0, childIn; (childIn = xml.childNodes[i]); i++) {
    if (!childIn.tagName) {
      // Skip over text.
      continue;
    }
    switch (childIn.tagName.toUpperCase()) {
      case 'CATEGORY':
        // Decode the category name for any potential message references
        // (eg. `%{BKY_CATEGORY_NAME_LOGIC}`).
        var categoryName = Blockly.utils.replaceMessageReferences(
            childIn.getAttribute('name'));
        var category = Blockly.categoryRegistry.fromName(categoryName);
        if (category) {
          childIn = category.tree;
        }
        var childOut = this.createCategoryNode_(categoryName);
        treeOut.add(childOut);
        this.categories_[categoryName] = new Blockly.Toolbox.Category(categoryName, childIn);
        var custom = childIn.getAttribute('custom');
        if (custom) {
          // Variables and procedures are special dynamic categories.
          childOut.contents = custom;
        } else {
          var newOpenNode = this.syncTrees_(childIn, childOut, pathToMedia);
          if (newOpenNode) {
            openNode = newOpenNode;
          }
        }
        this.setStyleOrColour(childIn, childOut, categoryName);
        if (childIn.getAttribute('expanded') == 'true') {
          if (childOut.contents.length) {
            // This is a category that directly contains blocks.
            // After the tree is rendered, open this category and show flyout.
            openNode = childOut;
          }
          childOut.setExpanded(true);
        } else {
          childOut.setExpanded(false);
        }
        lastElement = childIn;
        break;
      case 'SEP':
        if (lastElement && lastElement.tagName.toUpperCase() == 'CATEGORY') {
          // Separator between two categories.
          // <sep></sep>
          treeOut.add(new Blockly.Toolbox.TreeSeparator(
              /** @type {!Blockly.tree.BaseNode.Config} */
              (this.treeSeparatorConfig_)));
          break;
        }
        // Otherwise falls through.
      case 'BLOCK':
      case 'SHADOW':
      case 'LABEL':
      case 'BUTTON':
        treeOut.contents.push(childIn);
        lastElement = childIn;
        break;
    }
  }
  return openNode;
};
